\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{float}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage[utf8]{inputenc} % for Unicode input
\usepackage[T1]{fontenc} % for font encoding
\usepackage{lmodern} % Latin Modern font that supports the T1 encoding
\usepackage{textcomp} % for additional symbols
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{setspace}
\usepackage{enumitem}
\usepackage{hyperref}

% Define colors for code listing
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Setup the style for the Python code listings
\lstdefinestyle{pythonstyle}{
    language=Python,
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

% Setup the style for plain text listings
\lstdefinestyle{plaintextstyle}{
    language={},
    basicstyle=\ttfamily,
    frame=single,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    numbers=left,
    numberstyle=\small,
    numbersep=8pt,
    showstringspaces=false,
    tabsize=2,
    language=bash,
    captionpos=b
}


% Adjust margins as needed
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
}

\title{Algorithm Analysis}
\author{Abraham J. Reines} % Replace [Your Name] with your actual name.
\date{\today} % Use the date of document completion.

\begin{document}

\maketitle

\section*{Task 6.3.1}

In the examination of the asymptotic behavior of the function $f(n) = 10^{12}n^3 + 10^6n^2 + n + 1$ against the polynomial $g(n) = n^4$, we have applied theoretical analysis complemented by limit calculations using SymPy to derive the following conclusions:

\begin{enumerate}
    \item \textbf{Is \( 10^{12}n^3 + 10^6n^2 + n + 1 \) not equivalent to \( \Theta(n^4) \)?}\\
    Yes. \( 10^{12}n^3 + 10^6n^2 + n + 1 \) is not \( \Theta(n^4) \) because the highest order term, \( n^3 \), dictates the growth rate of the function. As \( n \) approaches infinity, the \( n^4 \) term would grow faster than the \( n^3 \) term. Hence, \( 10^{12}n^3 + 10^6n^2 + n + 1 \) is \( \Theta(n^3) \), not \( \Theta(n^4) \).

    \item \textbf{Is \( 10^{12}n^3 + 10^6n^2 + n + 1 \) equivalent to \( o(n^4) \)?}\\
    Yes. \( 10^{12}n^3 + 10^6n^2 + n + 1 \) is \( o(n^4) \) because as \( n \) grows, the function \( 10^{12}n^3 + 10^6n^2 + n + 1 \) increases at a slower rate than any function proportional to \( n^4 \). Thus, it can be bounded above by \( C \cdot n^4 \) for some constant \( C \) and sufficiently large \( n \).

    \item \textbf{Is \( 10^{12}n^3 + 10^6n^2 + n + 1 \) equivalent to \( \omega(n^4) \)?}\\
    No. \( 10^{12}n^3 + 10^6n^2 + n + 1 \) is not \( \omega(n^4) \) because it does not grow faster than any function proportional to \( n^4 \). For \( f(n) \) to be \( \omega(g(n)) \), \( f(n) \) must eventually exceed \( C \cdot g(n) \) for any constant \( C \), which is not the case here as \( n^3 \) is the dominant term in \( f(n) \), and it grows slower than \( n^4 \).
\end{enumerate}

These findings underscore the importance of both theoretical and computational methods in the analysis of algorithmic complexity.


\section*{6.3.2}

\section*{Application Case:}
\begin{itemize}
    \item 250GB hard disk with 160GB of files.
    \item CPU with one core, 4GHz clock speed, and 64-bit registers.
    \item Capable of \(4 \times 10^9\) 8-character comparisons per second.
\end{itemize}

\section*{Search Time Analysis}

\begin{enumerate}
    \item \textbf{Single 1KB Signature:}
    
    The time required to search with a single 1KB signature is computed to be approximately 5 seconds. This duration represents the worst-case scenario, providing a concrete timeframe for completing a single search cycle. It is important to note that the Boyer-Moore algorithm will often perform faster than this worst-case estimate due to its pattern-skipping feature.
    
    \item \textbf{Database of 1 Million 1KB Signatures:}
    
    Scaling up the search to account for a database of 1 million 1KB signatures, the total time estimated for the search is approximately 57.87 days, assuming a worst-case scenario where each signature search is independent and linear. The actual performance of the Boyer-Moore algorithm is expected to be better due to its sublinear average-case performance.
    
    \item \textbf{Improving Efficiency:}
    
    To further improve the efficiency of malware/virus detection through string matching, we can utilize parallel processing by distributing the search workload across multiple CPU cores or even different machines. Additionally, implementing more advanced string matching algorithms such as Aho-Corasick, which is designed for searching multiple patterns simultaneously, can significantly reduce the time complexity. Optimizing the algorithm to take advantage of the preprocessing of the virus signatures and employing heuristic methods to skip unlikely sections of data can also enhance performance.  
    
\end{enumerate}

%\newpage
\section*{Scripting}

%\lstinputlisting[style=pythonstyle, caption={Content from CheckingLimits.py}]{CheckingLimits.py}

%\lstinputlisting[style=pythonstyle, caption={Content from BackofEnvelope.py}]{BackofEnvelope.py}

\newpage
\section*{References}

\vfill 
  \section*{Academic Integrity Pledge}
   {\color{red}\textit{“This work complies with the JMU honor code. I did not give or receive unauthorized help on this assignment.”}}
\end{document}
